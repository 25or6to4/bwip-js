// file: node-bwipjs
//
// Copyright (c) 2011-2015 Mark Warren
//
// See the LICENSE file in the bwip-js root directory
// for the extended copyright notice.
//
// A modified version of PNGlib.js is included in this file and is licensed:
//
// Copyright (c) 2010, Robert Eisele
// http://www.xarg.org/2010/03/generate-client-side-png-files-using-javascript/
// http://www.opensource.org/licenses/bsd-license.php BSD License
//
// ----------------------------------------------------------------------
// Node-js module for bwip-js.
//
// Usage:
//		var bwipjs = require('./node-bwipjs');
//
// bwipjs is a request handler with the standard node HTTP server request
// prototype:
//
//		function bwipjs(request, response)
//
// The bar code parameters are encoded entirely as URL query strings.
// The file path and other attributes of the URL are ignored.
//
// Possible values to specify in the query string are:
//
// `bcid` is the name of the bwip-js barcode rendering function e.g.
//
//		bcid=code128
//
// `text` is the text to be bar coded.
//
// `scaleX` is the x-axis multiplier.  Should be an integer > 0.
// `scaleY` is the y-axis multiplier.  Should be an integer > 0. 
// `scale` is shorthand for specifying the same value for scaleX and scaleY.
//
// `rotate` takes the values: 
//		N	normal, unrotated (the default)
//		R	clockwise, 90 rotation
//		L	counter-clockwise, 90 rotation
//		I	inverted, 180 rotation
//
// Plus any of the bar code options defined in the BWIPP documentation.
//
// For example:
//
//		http://127.0.0.1:3030/?bcid=code128&text=^FNC1011234567890&scale=4&
//					rotate=L&parsefnc&alttext=(01)1234567890
//
// For a complete list of encoder bcid names, see:
//
//  https://github.com/metafloor/bwip-js/wiki/Supported-Barcode-Symbologies
//
// This module uses a simple PNG encoding library based on the work
// by Robert Eisele (PNGlib).  No compression is used, which makes the
// rendered images much larger than necessary.
//
var url	= require('url');
var fs	= require('fs');
var vm	= require('vm');

var Module  = require('./freetype.js');
var sandbox = vm.createContext({ Module:Module });

// Set the hook for demand-loading the remaining bwip-js files
function load(path) {
	var text = fs.readFileSync(path);
	if (!text)
		throw new Error(path + ": could not read file");

	vm.runInContext(text, sandbox, { filename:path });
}

function error(res, status, message) {
	res.writeHead(status, { 'Content-Type':'text/plain' });
	res.end(message, 'ascii');
}

// This module exports a single function - the bwip-js request handler
module.exports = function(req, res) {
	if (typeof sandbox.BWIPJS === 'undefined') {
		// Finish loading bwip-js, after freetype is done.
		load('./bwip.js');
		sandbox.BWIPJS.load = load;
	}

	// If the url does not begin /?bcid= then 404.  Otherwise, we end up
	// returning 400 on requests like favicon.ico.
	if (req.url.indexOf('/?bcid=') != 0)
		return error(res, 404, 'Unknown request format.\r\n');

	var args = url.parse(req.url, true).query;

	// Set the defaults
	var scale	= args.scale || 2;
	var scaleX	= +args.scaleX || scale;
	var scaleY	= +args.scaleY || scale;
	var rot		= args.rotate || 'N';
	var bcid	= args.bcid;
	var text	= args.text;

	if (!text)
		return error(res, 400, 'Bar code text not specified.\r\n');
	if (!bcid)
		return error(res, 400, 'Bar code type not specified.\r\n');
	if (!fs.existsSync('bwipp/' + bcid + '.js'))
		return error(res, 400, 'Bar code type "' + bcid + '" unknown.\r\n');

	// Remove the non-BWIPP options
	delete args.scale;
	delete args.scaleX;
	delete args.scaleY;
	delete args.rotate;
	delete args.text;
	delete args.bcid;

	// Initialize a barcode writer object
	var bw = new sandbox.BWIPJS;

	// Set the options
	var opts = {};
	for (id in args) {
		// options that do not take a value e.g. parsefnc
		if (!args[id])
			opts[id] = bw.value(true);
		else
			opts[id] = bw.value(args[id]);
	}

	// Fix a disconnect in the BWIPP rendering logic
	if (opts.alttext)
		opts.includetext = bw.value(true);

	// Render the bar code
	bw.bitmap(new Bitmap);
	bw.scale(scaleX, scaleY);
	bw.push(text);
	bw.push(opts);

	// We load synchronously, so the callback is only needed for error handling...
	bw.call(bcid, function(e) {
		if (e) {
			return error(res, 400, 'BWIP-JS ERROR: ' + e + '\r\n');
		}
	});

	// Return a PNG-encoded image
	var png = bw.bitmap().getPNG(rot);
	if (!png)
		return error(res, 400, 'Too many colors.\r\n');
		
	res.writeHead(200, { 'Content-Type':'image/png' });
	res.end(png, 'binary');
};


// bwip-js bitmap interface
function Bitmap() {
	var _clrr = 0;					// current red
	var _clrg = 0;					// current green
	var _clrb = 0;					// current blue

	var _clrs = {};					// color map
	var _nclr = 1;					// color count - non-zero truthy
	var _pixs = {};					// x,y = rgb
	var _minx = Infinity;
	var _miny = Infinity;
	var _maxx = 0;
	var _maxy = 0;

	this.color = function(r,g,b) {
		_clrr = r;
		_clrg = g;
		_clrb = b;
	}

	this.set = function(x, y, a) {
		// postscript graphics work with floating-pt numbers
		x = Math.floor(x);
		y = Math.floor(y);

		if (_minx > x) _minx = x;
		if (_maxx < x) _maxx = x;
		if (_miny > y) _miny = y;
		if (_maxy < y) _maxy = y;
		
		var xy	= x + ',' + y;
		var cx	= _pixs[xy];
		var r, g, b;
		if (cx === undefined) {
			r = _clrr;
			g = _clrg;
			b = _clrb;
		} else {
			// alpha-blend with the existing color
			// dst is the existing "background" color
			// src is the new color
			var dsta = (cx >>> 24) / 255;
			var dstr = (cx >>> 16) & 0xff;
			var dstg = (cx >>>  8) & 0xff;
			var dstb = cx & 0xff;
			var srca = a / 255;
			var newa = srca + dsta * (1 - srca);	// new alpha 0.0 - 1.0
			if (!newa) {
				r = g = b = a = 0;
			} else {
				r = ((_clrr * srca + dstr * dsta * (1 - srca)) / newa)|0;
				g = ((_clrg * srca + dstg * dsta * (1 - srca)) / newa)|0;
				b = ((_clrb * srca + dstb * dsta * (1 - srca)) / newa)|0;
				a = (newa * 255)|0;
			}
		}

		var argb = (a << 24) | (r << 16) | (g << 8) | b;
		if (!_clrs[argb]) {
			_clrs[argb] = _nclr++;
		}
		_pixs[xy] = argb;
	}

	this.getPNG = function(rot) {
		if (_nclr > 256)
			return null;

		// determine image width and height
		if (rot == 'R' || rot == 'L') {
			var h = _maxx-_minx+1;
			var w = _maxy-_miny+1;
		} else {
			var w = _maxx-_minx+1;
			var h = _maxy-_miny+1;
		}

		var png = new PNGlib(w, h, 256);

		// Background is fully transparent
		png.color(0, 0, 0, 0);

		// map the colors
		var cmap = [];
		for (argb in _clrs) {
			cmap[argb] = png.color((argb>>16)&0xff, (argb>>8)&0xff, (argb&0xff),
									argb>>>24);
		}

		for (var xy in _pixs) {
			var pts = xy.split(',');
			var x	= +pts[0] - _minx;
			var y	= +pts[1] - _miny;

			// PostScript builds bottom-up, we build top-down.
			if (rot == 'N') {
				y = h - y - 1; 	// Invert y
			} else if (rot == 'I') {
				x = w - x - 1;	// Invert x
			} else {
				y = w - y; 		// Invert y
				if (rot == 'L') {
					var t = y;
					y = h - x - 1;
					x = t - 1;
				} else {
					var t = x;
					x = w - y;
					y = t;
				}
			}
			png.set(x, y, cmap[_pixs[xy]]);
		}

		return png.render();
	}
}

/**
* pnglib.js
* @version 1.0
* @author Robert Eisele <robert@xarg.org>
* @copyright Copyright (c) 2010, Robert Eisele
* @link http://www.xarg.org/2010/03/generate-client-side-png-files-using-javascript/
* @license http://www.opensource.org/licenses/bsd-license.php BSD License
*/
// Modified by MRW for use with bwip-js.
function PNGlib(width,height,depth) {

	// helper functions for that ctx
	function write(buffer, offs) {
		for (var i = 2; i < arguments.length; i++) {
			for (var j = 0; j < arguments[i].length; j++) {
				buffer[offs++] = arguments[i].charAt(j);
			}
		}
	}

	function byte2(w) {
		return String.fromCharCode((w >> 8) & 255, w & 255);
	}

	function byte4(w) {
		return String.fromCharCode((w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w & 255);
	}

	function byte2lsb(w) {
		return String.fromCharCode(w & 255, (w >> 8) & 255);
	}

	this.width   = width;
	this.height  = height;
	this.depth   = depth;

	// pixel data and row filter identifier size
	this.pix_size = height * (width + 1);

	// deflate header, pix_size, block headers, adler32 checksum
	this.data_size = 2 + this.pix_size +
					5 * Math.floor((0xfffe + this.pix_size) / 0xffff) + 4;

	// offsets and sizes of Png chunks
	this.ihdr_offs = 0;
	this.ihdr_size = 4 + 4 + 13 + 4;
	this.plte_offs = this.ihdr_offs + this.ihdr_size;
	this.plte_size = 4 + 4 + 3 * depth + 4;
	this.trns_offs = this.plte_offs + this.plte_size;
	this.trns_size = 4 + 4 + depth + 4;
	this.idat_offs = this.trns_offs + this.trns_size;
	this.idat_size = 4 + 4 + this.data_size + 4;
	this.iend_offs = this.idat_offs + this.idat_size;
	this.iend_size = 4 + 4 + 4;
	this.buffer_size  = this.iend_offs + this.iend_size;

	this.buffer  = new Array();
	this.palette = new Object();
	this.pindex  = 0;

	var _crc32 = new Array();

	// initialize buffer with zero bytes
	for (var i = 0; i < this.buffer_size; i++) {
		this.buffer[i] = "\x00";
	}

	// initialize non-zero elements
	write(this.buffer, this.ihdr_offs, byte4(this.ihdr_size - 12), 'IHDR',
					byte4(width), byte4(height), "\x08\x03");
	write(this.buffer, this.plte_offs, byte4(this.plte_size - 12), 'PLTE');
	write(this.buffer, this.trns_offs, byte4(this.trns_size - 12), 'tRNS');
	write(this.buffer, this.idat_offs, byte4(this.idat_size - 12), 'IDAT');
	write(this.buffer, this.iend_offs, byte4(this.iend_size - 12), 'IEND');

	// initialize deflate header
	var header = ((8 + (7 << 4)) << 8) | (3 << 6);
	header+= 31 - (header % 31);

	write(this.buffer, this.idat_offs + 8, byte2(header));

	// initialize deflate block headers
	for (var i = 0; (i << 16) - 1 < this.pix_size; i++) {
		var size, bits;
		if (i + 0xffff < this.pix_size) {
			size = 0xffff;
			bits = "\x00";
		} else {
			size = this.pix_size - (i << 16) - i;
			bits = "\x01";
		}
		write(this.buffer, this.idat_offs + 8 + 2 + (i << 16) + (i << 2),
					bits, byte2lsb(size), byte2lsb(~size));
	}

	/* Create crc32 lookup table */
	for (var i = 0; i < 256; i++) {
		var c = i;
		for (var j = 0; j < 8; j++) {
			if (c & 1) {
				c = -306674912 ^ ((c >> 1) & 0x7fffffff);
			} else {
				c = (c >> 1) & 0x7fffffff;
			}
		}
		_crc32[i] = c;
	}

	// used internally
	this.index = function(x,y) {
		var i = y * (this.width + 1) + x + 1;
		var j = this.idat_offs + 8+2+5 * Math.floor((i / 0xffff) + 1)+i;
		return j;
	}

	// set a pixel to the given color
	this.set = function(x,y,c) {
		var i = y * (this.width + 1) + x + 1;
		var j = this.idat_offs + 8+2+5 * Math.floor((i / 0xffff) + 1)+i;
		this.buffer[j] = c;
	}

	// convert a color and build up the palette
	this.color = function(red, green, blue, alpha) {

		alpha = alpha >= 0 ? alpha : 255;
		var color = (((((alpha << 8) | red) << 8) | green) << 8) | blue;

		if (typeof this.palette[color] == "undefined") {
			if (this.pindex == this.depth) return "\x00";

			var ndx = this.plte_offs + 8 + 3 * this.pindex;

			this.buffer[ndx + 0] = String.fromCharCode(red);
			this.buffer[ndx + 1] = String.fromCharCode(green);
			this.buffer[ndx + 2] = String.fromCharCode(blue);
			this.buffer[this.trns_offs+8+this.pindex] =
											String.fromCharCode(alpha);

			this.palette[color] = String.fromCharCode(this.pindex++);
		}
		return this.palette[color];
	}

	// output a PNG string
	this.render = function() {

		// compute adler32 of output pixels + row filter bytes
		// NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <=
		// 2^32-1.
		var BASE = 65521; /* largest prime smaller than 65536 */
		var NMAX = 5552; 
		var s1 = 1;
		var s2 = 0;
		var n = NMAX;

		for (var y = 0; y < this.height; y++) {
			for (var x = -1; x < this.width; x++) {
				s1+= this.buffer[this.index(x, y)].charCodeAt(0);
				s2+= s1;
				if ((n-= 1) == 0) {
					s1%= BASE;
					s2%= BASE;
					n = NMAX;
				}
			}
		}
		s1%= BASE;
		s2%= BASE;
		write(this.buffer, this.idat_offs + this.idat_size - 8,
				byte4((s2 << 16) | s1));

		// compute crc32 of the PNG chunks
		function crc32(png, offs, size) {
			var crc = -1;
			for (var i = 4; i < size-4; i += 1) {
				crc = _crc32[(crc ^ png[offs+i].charCodeAt(0)) & 0xff] ^ ((crc >> 8) & 0x00ffffff);
			}
			write(png, offs+size-4, byte4(crc ^ -1));
		}

		crc32(this.buffer, this.ihdr_offs, this.ihdr_size);
		crc32(this.buffer, this.plte_offs, this.plte_size);
		crc32(this.buffer, this.trns_offs, this.trns_size);
		crc32(this.buffer, this.idat_offs, this.idat_size);
		crc32(this.buffer, this.iend_offs, this.iend_size);

		// convert PNG to string
		return "\211PNG\r\n\032\n"+this.buffer.join('');
	}
}

